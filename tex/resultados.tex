\chapter{Resultados} \label{ch:RD}



% \section{Seção de exemplo 1 - Códigos} \label{sec:resex1}

% \subsection{Subseção de exemplo 1 - Inserindo trechos de códigos}
 
% O nosso querido Leonardo Cavalcante providenciou um comando que deixa nossos trechos de códigos bonitinhos e gera um elemento pré-textual de Lista de Códigos. 

% Os códigos são adicionados através do comando seguinte:

% \textbackslash sourcecode\{ Descrição \}\{Label\}\{Linguagem\}\{Arquivo com extensão\}

% Um exemplo pode ser visto no código \ref{cmd:cron} abaixo.

% %\sourcecode{Configuração do intervalo de execução no Script Agendador}{cron}{javascript}{cron.js}


% \section{Seção de exemplo 2 - Listas} \label{sec:resex2}

% \subsection{Subseção de exemplo 2 - Lista de itens} 

% Existem alguns tipos de listas no Latex, iremos exemplificar a lista sem numeração (seção \ref{subsubsec:itemize}), a lista enumerada (seção \ref{subsubsec:enumerate}) e a lista mista (seção \ref{subsubsec:mista}). As listas podem ser encadeadas de diversas maneiras,
% de acordo com a necessidade do autor.

% \subsubsection{Subsubseção de exemplo 1 - Lista sem numeração} \label{subsubsec:itemize}

% Este é um exemplo de lista sem numeração.

% \begin{itemize}
% 	\item \textbf{Cadastrar usuário}

% 		\begin{itemize}
%     		\item Atores
% 		    	\begin{itemize}
%     		    	\item Usuário
% 		    	\end{itemize}

% 	    	\item Fluxo de eventos primário
% 			    \begin{itemize}
% 	    		    \item o usuário deve se cadastrar informando seu nome, \textit{e-mail} e senha;
% 		        	\item a API armazena os dados do usuário;
% 		    	    \item o usuário é liberado para realizar o \textit{login}.
% 			    \end{itemize}

%     		\item Fluxo alternativo
% 			    \begin{itemize}
% 		    	   \item o usuário desiste de se cadastrar e cancela o caso de uso clicando no botão voltar.
% 	    		\end{itemize}

% 		\end{itemize}
	
% \end{itemize}

% \subsubsection{Subsubseção de exemplo 2 - Lista enumerada} \label{subsubsec:enumerate}

% Este é um exemplo de lista enumerada.

% \begin{enumerate}
% 	\item O Usuário deseja ver o histórico das variáveis climáticas, então através da interface de usuário escolhe o período ao qual o histórico se refere;
% 	\item A aplicação solicita à API através de uma requisição HTTP contendo o momento de início e o momento do fim do período em seus parâmetros;     			\item A API recebe a solicitação e se comunica com a base de dados, então requere as informações quem possuem a data de leitura no intervalo escolhido;
% 	\item A base de dados retorna os dados em formato Json para a API;
% 	\item A API responde à requisição retornando os dados, também em formato Json, para a aplicação cliente;
% 	\item A aplicação cliente renderiza os gráficos utilizando o conjunto de dados obtidos.
% \end{enumerate}

% \subsubsection{Subsubseção de exemplo 3 - Lista mista} \label{subsubsec:mista}

% Este é um exemplo de lista mista.

% \begin{itemize}
% 	\item \textbf{Cadastrar usuário}

% 		\begin{itemize}
%     		\item Atores
% 		    	\begin{itemize}
%     		    	\item Usuário
% 		    	\end{itemize}

% 	    	\item Fluxo de eventos primário
% 			    \begin{enumerate}
% 	    		    \item o usuário deve se cadastrar informando seu nome, \textit{e-mail} e senha;
% 		        	\item a API armazena os dados do usuário;
% 		    	    \item o usuário é liberado para realizar o \textit{login}.
% 			    \end{enumerate}

%     		\item Fluxo alternativo
% 			    \begin{itemize}
% 		    	   \item o usuário desiste de se cadastrar e cancela o caso de uso clicando no botão voltar.
% 	    		\end{itemize}

% 		\end{itemize}

% 	\item \textbf{Visualizar dados atuais}

% 		\begin{itemize}
% 		    \item Atores
% 	    		\begin{itemize}
% 		    	    \item Usuário
% 			    \end{itemize}
    
% 	    	\item Pré-condições
% 			    \begin{itemize}
% 		     	   \item o usuário deve estar autenticado
% 			    \end{itemize}

% 	    	\item Fluxo de eventos primário
% 			    \begin{enumerate}
% 		    	    \item o usuário deve efetuar o \textit{login} informando o \textit{e-mail} e a senha;
% 	    		    \item caso o usuário não seja autenticado, o sistema informa a respeito de credenciais inválidas e encerra o caso de uso;
% 		    	    \item a API autentica o usuário;
%     			    \item o usuário é liberado para visualizar os dados atuais dos sensores da estação;
% 		        	\item após a visualização o usuário pode finalizar o caso de uso ou efetuar uma nova consulta se desejar.
% 			    \end{enumerate}

%     		\item Fluxo alternativo
% 			    \begin{itemize}
%     			   \item o usuário desiste de visualizar os dados atuais e cancela o caso de uso clicando no botão voltar.
% 			    \end{itemize}

% 		\end{itemize}

% 	\item \textbf{Visualizar histórico}

% 		\begin{itemize}
% 		    \item Atores
% 	    		\begin{itemize}
% 		    	    \item Usuário
% 	    		\end{itemize}

% 	    	\item Pré-condições
%     			\begin{itemize}
% 			        \item o usuário deve estar autenticado
% 			    \end{itemize}

% 		    \item Fluxo de eventos primário
% 			    \begin{enumerate}
% 			        \item o usuário deve efetuar o \textit{login} informando o \textit{e-mail} e a senha;
% 			        \item caso o usuário não seja autenticado, o sistema informa a respeito de credenciais inválidas e encerra o caso de uso;
% 			        \item a API autentica o usuário;
% 			        \item o usuário é liberado para escolher qual período cujo histórico será exibido;
% 			        \item o usuário seleciona as variáveis a serem exibidas no gráficos de linhas;
% 			        \item após a visualização do histórico o usuário pode finalizar o caso de uso se desejar.
% 			    \end{enumerate}

% 		    \item Fluxo alternativo
% 			    \begin{enumerate}
% 			        \item após a escolha do período de exibição do histórico o usuário pode voltar para a tela anterior e escolher um novo período;
% 			        \item o histórico é exibido para o usuário;
% 			        \item após a visualização do histórico o usuário pode finalizar o caso de uso ou efetuar uma nova consulta se desejar.
% 			    \end{enumerate}

% 		    \item Fluxo alternativo
% 			    \begin{enumerate}
% 			        \item o usuário desiste de visualizar o histórico e cancela o caso de uso clicando no botão voltar.
% 			    \end{enumerate}
% 		\end{itemize}
% \end{itemize}

\section{Modelagem iterativa do sistema em Simulink}
\label{sbs:etapa5}

Após a finalização da criação dos cenários \textit{Gherkin}, a implementação prossegue com o desenvolvimento do modelo e das definições de passos. Inicialmente, o modelo é 
criado dentro da estrutura do projeto, em uma nova pasta denominada \textit{model}. O conteúdo desta pasta inclui:

\begin{itemize}
	\item \textbf{feature\_model.slx} - modelo caixa preta, utilizado nos testes;
	\item \textbf{main.slx} - modelo de caixa branca, que contém a lógica do sistema e é referenciado como um bloco subsystem dentro do modelo feature\_model.slx;
	\item \textbf{write\_to\_model.m} - função MATLAB responsável por operações de escrita no modelo;
	\item \textbf{read\_from\_model.m} - função MATLAB responsável por operações de leitura no modelo;
	\item \textbf{initialize\_model.m} - função matlab que inicia o modelo e torna a API da aplicação disponível para as funções das definições de passo.
\end{itemize}

O modelo \textbf{feature\_model.slx} segue a estrutura do diagrama de caixa preta, contendo apenas as entradas e saídas do sistema, sem detalhar sua lógica interna. Para 
isso, são utilizados blocos de constantes como entradas e \textit{displays} como saídas.

Durante a execução dos testes, as definições de passos simulam o comportamento do sistema ao interagir com suas entradas, modificando os valores das constantes por 
meio da função \textbf{write\_to\_model}. Para validar a resposta do sistema, os valores dos displays de saída, determinados pela lógica interna do modelo, são obtidos utilizando 
a função \textbf{read\_from\_model}.

\begin{figure}[H]
\centering
\includegraphics[height=7cm]{figuras/feature\_model.png}
\caption{Modelo \textbf{feature\_model.slx} que aplica o conceito de caixa preta.}
\label{fig:featuremodel}
\end{figure}

O modelo apresentado na Figura \ref{fig:featuremodel} contém entradas auxiliares que ainda não estão contempladas no diagrama de caixa preta. Essas entradas foram adicionadas para tornar certos 
comportamentos do sistema testáveis durante o desenvolvimento do modelo e serão detalhadas ao longo desta seção.

O segundo modelo, \textbf{main.slx}, é referenciado no bloco central do modelo anterior, denominado controller. Ele é responsável pela implementação da lógica interna 
do sistema em desenvolvimento, utilizando as entradas definidas como blocos \textit{Inport} e as saídas como \textit{Outport}, conectadas às constantes e \textit{displays} 
do \textbf{feature\_model.slx}.

Em seguida, o desenvolvimento do \textbf{environment.py} inclui funções em Python que tornam as operações de escrita e leitura do modelo acessíveis às definições de passos. 
Para isso, são criadas diversas funções utilitárias, permitindo realizar ações como:

\begin{itemize}
	\item Iniciar a simulação;
	\item Parar a simulação;
	\item Executar operações de escrita no modelo;
	\item Executar operações de leitura no modelo.
\end{itemize}

Essas funções utilitárias ficam disponíveis por meio do objeto context, o qual pode ser acessado diretamente na lógica das funções das definições de passos. Com isso, 
cada passo consegue interagir com o modelo ao executar as operações especificadas no arquivo \textbf{environment.py}.

Para garantir uma execução iterativa dos testes, cada história é validada individualmente em um primeiro momento. Após a sua aprovação, todas as histórias anteriores 
são executadas novamente, assegurando que a implementação de novas funcionalidades não comprometa o comportamento já estabelecido.

A execução dos testes é realizada após a definição da lógica interna das funções de cada passo. Os resultados são então documentados em um relatório automático, gerado 
em formato \textbf{.xml}, que descreve detalhadamente todas as falhas encontradas, conforme o padrão da figura \ref{fig:relatoriofeature}:

\begin{figure}[H]
\centering
\includegraphics[height=3cm]{figuras/teste\_feature.png}
\caption{Relatório de testes - resultado da execução do arquivo \textbf{.feature}.}
\label{fig:relatoriofeature}
\end{figure}

O relatório também apresenta os resultados da execução de passos específicos, organizados de acordo com a figura \ref{fig:relatoriocenario}:

\begin{figure}[H]
\centering
\includegraphics[height=5cm]{figuras/teste\_cenario.png}
\caption{Relatório de testes - resultados por cenário.}
\label{fig:relatoriocenario}
\end{figure}

O relatório apresentado na Figura \ref{fig:relatoriofeature} refere-se à execução dos cenários da história de usuário 1, como indicado pelo nome do arquivo 
\textbf{.feature} \texttt{lock\_all.Lock All}. Os resultados indicam a realização de um total de 20 testes, que são compostos pelos 16 exemplos do primeiro 
cenário e pelos 4 exemplos do segundo. Observa-se também que a execução durou 330 segundos e não apresentou erros, falhas ou testes pulados, indicando que 
todos os testes foram aprovados.

Na seção de execução detalhada do relatório, ilustrada na Figura \ref{fig:relatoriocenario}, observa-se que o cenário em questão é \texttt{Locking all doors} 
(primeiro cenário do arquivo \textbf{.feature}), correspondente ao exemplo \texttt{@1.1} (primeira linha da primeira tabela de exemplos). Cada passo do 
cenário apresenta seu respectivo resultado de execução, identificado como \texttt{passed}, além do tempo necessário para sua conclusão.

Além das informações detalhadas nas Figuras \ref{fig:relatoriofeature} e \ref{fig:relatoriocenario}, para facilitar a análise de falhas, as funções implementadas 
em \textbf{environment.py} registram no relatório todas as interações realizadas com o modelo. Isso permite validar manualmente se a execução dos testes ocorreu 
conforme o esperado.

\subsection{Execução dos testes de aceitação da História de Usuário 1}

A execução dos cenários desta história inicia-se com o modelo vazio, o que resulta em falhas na validação de dois comportamentos:

\begin{itemize}
	\item Definição dos estados iniciais de travamento das portas, conforme descrito na cláusula \textit{Given};
	\item Travamento de todas as portas ao pressionar o botão de travamento.
\end{itemize}

O primeiro ponto decorre do fato de que, em ambos os cenários, a cláusula \textit{Given} estabelece valores iniciais para o estado de travamento de cada porta. Contudo, 
o teste falha porque o modelo não possui a implementação de um mecanismo que permita modificar diretamente o valor da saída nesse momento.

Para viabilizar essa estrutura, foi criada uma interface auxiliar denominada \textbf{manual\_lock}, que possibilita alterar o estado inicial das portas sem recorrer aos 
botões físicos ou ao sistema \textit{Keyless Access}. Essa interface executa uma operação de escrita direta no bloco \textit{Data Store Memory}, responsável por armazenar o 
estado de travamento das portas no modelo.

A adoção de uma interface auxiliar para definir o estado inicial de travamento de cada porta tem como objetivo preservar a independência entre as funcionalidades. 
Conforme mencionado anteriormente, é possível obter qualquer combinação de travamento ou destravamento por meio do \textit{Keyless Access} em portas específicas. 
Entretanto, para que essa sequência de entradas fosse utilizada diretamente na definição do primeiro passo, seria necessário que a história de usuário do 
\textit{Keyless Access} já estivesse implementada e operacional.

Tanto a interface quanto o bloco de memória utilizam um valor inteiro de 4 bits, no qual cada bit representa o estado de travamento de uma porta. Como cada passo 
define de forma independente o estado de cada porta, a lógica da função de definição altera apenas o bit correspondente à porta em questão.

No segundo ponto identificado, a lógica implementada para o travamento das portas utiliza a interface de entrada do botão de travamento como gatilho de um 
\textit{Triggered Subsystem}. Quando o valor do botão altera de 0 para 1, o valor 15 — que corresponde ao bit 1 ativado em cada uma das quatro portas — é gravado 
no \textit{Data Store Memory}.

Com essa implementação, todos os testes da primeira história são aprovados, embora nenhuma lógica de abertura das portas tenha sido desenvolvida até o momento. Isso 
ocorre porque o valor esperado no resultado final corresponde ao estado de porta segura (saída igual a 0), o que coincide com o valor padrão atribuído pelo Simulink.

Essa coincidência leva à aprovação do teste, ainda que represente um falso positivo. A situação, contudo, será corretamente tratada na execução dos testes da segunda 
história, em que o valor esperado é o de porta aberta.


\subsection{Execução dos testes de aceitação da História de Usuário 2}

Na execução dos cenários da segunda história de usuário, foram identificadas falhas nos seguintes comportamentos:

\begin{itemize}
	\item Destravamento das portas ao acionar o botão de destravamento;
	\item Abertura de portas específicas ao acionar o botão de abertura.
\end{itemize}

Para atender à condição de destravamento, aplica-se uma lógica semelhante à utilizada no travamento, baseada em um bloco \textit{Triggered Subsystem}. Nesse caso, 
a escrita na memória é realizada com o valor inteiro 0, indicando que todos os quatro bits possuem valor 0.

Já para a condição de abertura das portas, a lógica de implementação pode ser construída de diferentes formas. Um exemplo, ainda que sem sentido do ponto de vista 
funcional do sistema, mas suficiente para satisfazer os testes, seria manter as portas permanentemente abertas, conectando diretamente o valor 1 às saídas. Contudo, 
essa abordagem é inviável, pois compromete a execução da primeira história, resultando em falhas na implementação anterior ao repetir os testes.

Sob essa perspectiva, o design que satisfaz ambos os testes consiste em permitir a abertura das portas apenas quando duas condições são atendidas simultaneamente:

\begin{itemize}
	\item A porta está destravada - assegura que a abertura não ocorre enquanto a porta estiver travada;
	\item O botão de abertura está pressionado - garante que a porta permaneça fechada mesmo quando destravada, caso o botão não seja acionado.
\end{itemize}

Para implementar essa lógica, utiliza-se um bloco \textit{AND}, que recebe como entradas o estado do botão de abertura e a condição de não travamento da porta. Essa 
estrutura é replicada para cada porta, empregando as interfaces correspondentes e operações de manipulação de bits para extrair do bloco de memória o estado atual 
de travamento de cada uma.


\subsection{Execução dos testes de aceitação da História de Usuário 3}

Na terceira história de usuário, foram identificadas as seguintes falhas de comportamento:

\begin{itemize}
	\item Definição das condições para cada status;
	\item Utilização do tempo de espera para validar a saída de travamento em relação ao valor esperado;
	\item Indicação da atualização de status;
	\item Todas as portas devem ser fechadas durante o início dos testes.
\end{itemize}

O primeiro ponto observado nos testes ocorre porque a saída de status permanece inicialmente em 0, já que a lógica correspondente ainda não havia sido implementada. 
Para corrigir esse problema, as condições que determinam cada status foram modeladas em um bloco \textit{Chart}, que possui os 3 estados a seguir:

\begin{itemize}
	\item Confirmação de travamento: o botão de travamento é pressionado e, em seguida, todas as portas são travadas;
	\item Confirmação de destravamento: o botão de destravamento é pressionado e, em seguida, todas as portas são destravadas;
	\item Operação falha: o botão de travamento é pressionado enquanto ao menos um dos sensores de abertura indica que a porta está aberta.
\end{itemize}

Na teoria, as condições listadas deveriam satisfazer o comportamento esperado; entretanto, durante a execução dos testes, ainda foram observados erros. A investigação 
levantou a falha constatada no segundo ponto e exige uma pequena modificação nos cenários, incluindo uma condição temporal para validar que o status foi efetivamente 
gerado na saída.

Essa falha ocorre porque a implementação utiliza múltiplas entradas para determinar o status, o que ocasiona um leve atraso na execução do modelo. Esse efeito é 
particularmente relevante nos status de travamento e destravamento, que só são acionados após a atualização da saída de travamento.

Consequentemente, os testes falham não por falha no comportamento do sistema, mas porque o passo de validação do status é executado antes da atualização da saída no 
modelo. Para contornar esse problema, os passos dos cenários foram ajustados para incluir uma janela temporal, durante a qual o status deve ser gerado, conforme 
exemplificado abaixo:

\begin{verbatim}
	And I should receive a <feedback> feedback within '500' ms
\end{verbatim}


Para garantir que a implementação utilize valores de tempo compatíveis com a execução dos testes, foi criada uma nova interface auxiliar responsável por informar ao 
modelo o tempo atual da simulação. A cada passo executado, o arquivo \textbf{environment.py} atualiza o valor dessa interface de tempo com o valor gerado pelo Python. 
Esse valor é então considerado como uma condição adicional na determinação do status.

A terceira falha identificada decorreu de inconsistências observadas durante a execução dos testes. De forma aparentemente aleatória, o valor ``sem status'' era gerado 
repetidamente junto com o valor correto, como se o sistema estivesse oscilando continuamente entre os dois estados.

O problema foi evidenciado ao analisar o modelo, especificamente o comportamento interno do bloco \textit{Chart}, que contém o diagrama de estados. Inicialmente, a 
condição para iniciar a validação baseava-se apenas no acionamento do botão de travamento ou destravamento, verificando se o seu valor era 1 (pressionado). Isso 
provocava a repetição contínua da validação enquanto o botão permanecia pressionado, gerando os resultados inconsistentes observados nos testes.

A solução adotada consistiu em fazer com que a validação considerasse não o estado do botão em si, mas a transição de solto para pressionado. Dessa forma, assim que o 
teste indica que o botão foi pressionado, apenas um único evento de validação é gerado, garantindo que o status seja atualizado uma única vez na saída.

Para assegurar que os testes conseguissem detectar esse tipo de falha, a interface de status também foi aprimorada. Agora é possível identificar não apenas qual status 
está sendo indicado, mas também quando a saída é gerada. Isso é implementado por meio de um valor inteiro que é incrementado toda vez que um novo status é gerado, 
permitindo acompanhar a sequência de eventos na saída. A interface passa a assumir valores de 0 a 10, com a seguinte codificação:

\begin{itemize}
	\item 0 - Sem status
	\item 1, 4 e 7 - Confirmação de travamento
	\item 2, 5 e 8 - Confirmação de destravamento
	\item 3, 6 e 9 - Operação falha
\end{itemize}

Dessa forma, o incremento do valor de status é realizado de maneira condicional, dependendo do tipo de status a ser comunicado. Por exemplo, se o status atual 
for 2 e o sistema determinar que deve informar uma Confirmação de Travamento, o valor é incrementado para 4, que é o próximo valor disponível correspondente àquele status.

Quando o valor máximo é atingido, a interface realiza um loop, retornando aos valores iniciais. Por exemplo, se o estado atual for 8 e uma nova confirmação de 
destravamento precisar ser registrada, o valor é incrementado para 2.

Com base nessa estratégia, foi adicionada uma lógica de validação de status como função utilitária no \textbf{environment.py}. Essa função mantém uma lista de todos os valores 
de status, adicionando um novo item sempre que um novo status é gerado. Dessa forma, é possível validar não apenas se o resultado esperado foi alcançado, mas também se 
a quantidade correta de status foi registrada.

Por fim, um último problema foi identificado durante a execução repetida dos testes desta história: o feedback de operação falha era gerado em situações nas quais outro 
valor era esperado. A causa estava relacionada à interface do sensor de abertura das portas, que permanecia configurada como ``aberta'' em cenários que não especificavam 
explicitamente esse estado nos seus passos.

Esse comportamento ocorria porque, em cenários destinados a validar a saída considerando uma porta aberta, o valor atribuído ao modelo permanecia persistente, afetando 
a execução de cenários subsequentes ao manter indevidamente o estado de abertura.

Para corrigir essa inconsistência, foi adicionada uma precondição comum a todos os cenários, garantindo que cada teste seja iniciado com todas as portas fechadas. Essa 
configuração é feita por meio da funcionalidade \textit{Background}, utilizando o seguinte passo:

\begin{verbatim}
	Given all doors are 'closed'
\end{verbatim}

Dessa forma, todos os cenários iniciam com o passo do \textit{Background} e portanto as portas são sempre iniciadas com o valor fechado. Após a implementação dessa 
lógica, todos os cenários de todas as histórias foram executados novamente, sendo aprovados com sucesso.


\subsection{Execução dos testes de aceitação da História de Usuário 4}

Após a execução dos testes da quarta história de usuário, foram identificadas as seguintes falhas:

\begin{itemize}
	\item A porta não é destravada quando o botão de abertura é pressionado, mesmo com a chave presente;
	\item No início de todos os cenários, a chave não deve estar presente.
\end{itemize}

A primeira falha ocorre na validação do comportamento em que a porta deve ser destravada ao pressionar o botão de abertura com a chave presente. Isso se deve ao fato 
de que ainda não havia sido implementada uma lógica de destravamento que considerasse a presença da chave como critério para cada porta individual.

Para permitir essa funcionalidade, o destravamento de uma porta individual é realizado ao definir que um dos bits do \textit{Data Store Memory} deve assumir o valor 0. 
Essa operação é acionada através de um Triggered Subsystem, cuja execução ocorre somente quando duas condições são simultaneamente satisfeitas:

\begin{itemize}
	\item A chave está presente
	\item O botão de abertura da porta foi pressionado
\end{itemize}

Essa estrutura foi replicada para cada porta, ajustando a interface do botão de abertura correspondente e definindo qual bit do \textit{Data Store Memory} deve ser setado 
para 0. Após a implementação, todos os testes da história foram aprovados. No entanto, um novo problema foi identificado ao executar a história de usuário 1.

Durante os testes do \textit{Keyless Access}, a presença da chave é simulada no modelo ao escrever 1 no bloco de constante de entrada. O problema ocorre porque essa 
condição não é revertida em nenhum momento, fazendo com que, durante o teste que verifica que uma porta travada não pode ser aberta, o \textit{Keyless Access} seja 
aplicado inadvertidamente, permitindo que a porta se abra e causando a falha no teste.

Este problema é exatamente igual ao caso demonstrado na história anterior, e sua solução também utiliza o Background para definir estados iniciais comuns para todos 
os cenários. Neste caso os seguintes passos foram incluídos:

\begin{verbatim}
	Given I do not have an authenticated key with me
	And my vehicle is 'locked' with no release buttons pressed
\end{verbatim}

As definições desses passos garantem que a condição inicial de todas as entradas seja estabelecida no início da simulação, conforme descrito a seguir:

\begin{itemize}
	\item A chave não está presente;
	\item Todas as portas estão travadas;
	\item Nenhum dos botões de abertura está pressionado.
\end{itemize}

Dessa forma, ao iniciar a execução dos cenários da primeira história, a chave permanece ausente, o \textit{Keyless Access} não é acionado e a porta travada não se 
abre quando o botão de abertura é pressionado. Como resultado, todos os testes são aprovados.


\subsection{Execução dos testes de aceitação da História de Usuário 5}

Nesta história, foram identificados os seguintes problemas:

\begin{itemize}
	\item O travamento automático não ocorre após a passagem do tempo;
	\item As condições de abertura de uma porta, o estado inicial de travamento das portas e o acionamento do botão de destravamento duas vezes não impedem o travamento automático;
	\item Problema na determinação correta do tempo decorrido na simulação.
\end{itemize}

Os dois primeiros pontos estão diretamente relacionados à implementação da lógica responsável pelo auto travamento. Para tratá-los, utiliza-se um bloco \textit{Chart} 
contendo um diagrama de estados, no qual o pressionamento do botão de destravamento inicia a contagem de tempo. Esse diagrama é estruturado da seguinte maneira:

\begin{figure}[H]
\centering
\includegraphics[height=5cm]{figuras/diagrama\_auto\_travamento.png}
\caption{Diagrama de estados da lógica do auto travamento.}
%\label{fig:casos-uso}
\end{figure}

O sistema é iniciado no estado ``Nada'', no qual o auto-travamento não é verificado, permanecendo nessa condição até que seja atingida a situação válida para iniciar 
a contagem de tempo. Essa situação ocorre quando duas condições são simultaneamente satisfeitas:

\begin{itemize}
	\item Todas as portas estão travadas;
	\item O botão de travamento foi pressionado.
\end{itemize}

A primeira condição garante que o auto-travamento não será aplicado caso o veículo não esteja seguro inicialmente, atendendo ao último cenário de teste em que uma 
ou mais portas permanecem destravadas no início. Durante essa transição, o sistema registra o valor atual do tempo de simulação, permitindo determinar o momento em 
que a condição de passagem de 15 segundos é satisfeita.

Uma vez realizada a transição para o estado ``Esperando o tempo'', o sistema aguarda a passagem dos 15 segundos, enquanto monitora se alguma das condições que impedem 
o auto-travamento é satisfeita. Nessa situação, o sistema retorna ao estado ``Nada'' sem acionar o auto-travamento caso pelo menos uma das seguintes condições seja atendida:
\begin{itemize}
	\item Uma porta foi aberta;
	\item O botão de destravamento foi acionado.
\end{itemize}

Cada uma dessas condições corresponde a um cenário de teste, definindo os comportamentos em que o usuário manifesta a intenção de manter o veículo acessível. Por fim, 
caso nenhuma dessas condições seja satisfeita durante o período de espera, a passagem do tempo provoca a transição para o estado ``Travamento automático'', acionando 
o mesmo \textit{Triggered Subsystem} utilizado na história de travamento de todas as portas.

Dessa forma, o comportamento esperado do sistema em relação ao auto-travamento é completamente atendido. Entretanto, uma complicação técnica faz com que diversos 
testes falhem. Nos casos em que a espera é de 10 ou 14 segundos, os testes apresentam falha porque o auto-travamento é acionado antes que o tempo correto tenha decorrido.

A investigação revelou que esse problema ocorre devido à latência nas interações do Python com o modelo, que pode chegar a cerca de 500 ms por operação de escrita e 
200 ms por operação de leitura. Como inúmeras operações são executadas a cada instante, o valor do tempo gerado pelo Python é continuamente incrementado em operações 
que deveriam ser praticamente instantâneas.

Para resolver essa questão, a lógica de geração do tempo de simulação em Python foi ajustada para contabilizar o tempo gasto nas interações com o modelo. Dessa forma, 
a passagem do tempo de simulação é incrementada apenas durante passos que envolvem espera de tempo.

Essa abordagem foi adotada para garantir que a latência decorrente da interação entre as ferramentas não comprometesse a validade dos cenários de teste. Como a execução 
do modelo ocorre de forma independente da execução dos cenários, a indicação de tempo precisa refletir uma representação fiel do tempo real. Alternativas como a 
utilização de \textit{multi-threading} ou do tempo de simulação interno do Simulink ainda apresentariam problemas semelhantes e, por esse motivo, foram descartadas.

Após a correção da lógica de geração do tempo, todos os testes foram reexecutados, resultando em 100\% de aprovação em todos os cenários de todas as histórias de usuário.

\section{Análise dos Resultados}
\label{sbs:etapa6}

Ao fim do processo de modelagem iterativa, os resultados demonstrados na Figura \ref{fig:resultado-terminal} foram obtidos: 

\begin{figure}[H]
\centering
\includegraphics[height=3cm]{figuras/passed\_all\_tests.png}
\caption{Relatório de testes - execução final.}
\label{fig:resultado-terminal}
\end{figure}

A execução completa dos testes levou pouco mais de 31 minutos e contemplou:

\begin{itemize}
    \item 5 \textit{features};
    \item 101 cenários (incluindo combinação geradas pelas tabelas);
    \item 890 passos.
\end{itemize}

O Quadro \ref{qua:falhas} demonstra um sumário das falhas nos testes que foram capturadas durante a etapa, assim como uma demonstração da melhoria 
necessária para solucionar cada problema:

\begin{quadro}[H]
\caption{Falhas de comportamento capturadas durante a modelagem iterativa}
\label{qua:falhas}
\begin{tabular}{|p{7cm}|p{5cm}|}
\hline
Falha Capturada & Melhoria Implementada em \\ 
\hline
Definição dos estados iniciais de travamento das portas, conforme descrito na cláusula Given & Modelo \\
\hline
Travamento de todas as portas ao pressionar o botão de travamento & Modelo \\
\hline
Destravamento das portas ao acionar o botão de destravamento & Modelo \\
\hline
Abertura de portas específicas ao acionar o botão de abertura & Modelo \\
\hline
Definição das condições para cada status & Modelo \\
\hline
Utilização do tempo de espera para validar a saída de travamento em relação ao valor esperado & Cenários \\
\hline
Indicação da atualização de status & Definições dos passos \\
\hline
Todas as portas devem ser fechadas durante o início dos testes & Cenários \\
\hline
A porta não é destravada quando o botão de abertura é pressionado, mesmo com a chave presente & Modelo \\
\hline
No início de todos os cenários, a chave não deve estar presente & Cenários \\
\hline
O travamento automático não ocorre após a passagem do tempo & Modelo \\
\hline
As condições de abertura de uma porta, o estado inicial de travamento das portas e o acionamento do botão de destravamento duas vezes não impedem o travamento automático & Modelo \\
\hline
Problema na determinação correta do tempo decorrido na simulação & Definições dos passos  \\
\hline
\end{tabular}
\end{quadro}

Um total de 13 falhas foram levantadas, que culminaram na implementação de 8 melhorias no modelo, 3 melhorias no cenários e 2 melhorias nas definições dos passos. 

O processo iterativo demonstrou-se extremamente eficiente quando comparado a metodologias alternativas de desenvolvimento e testes de software embarcado. Um exemplo 
que ilustra claramente essa eficiência ocorreu durante a execução dos testes da história de usuário 3: a identificação das três primeiras falhas, bem como a implementação 
das respectivas soluções para atender aos cenários relevantes.

Os problemas encontrados estavam associados a detalhes específicos da implementação, cuja identificação exigiu uma visualização precisa do comportamento do sistema. 
Para tanto, foi necessário executar os testes repetidas vezes, realizando pequenos ajustes no modelo entre cada execução.

Em metodologias que realizam testes apenas após o lançamento do código embarcado, o processo análogo de identificação de falhas demandaria um número grande de 
compilações seguidas de testes. Além disso, a instrumentação utilizada nesse contexto pode apresentar limitações na observação do comportamento do sistema, o que 
dificultaria a detecção, por exemplo, de um loop indesejado.

Essas dificuldades são mitigadas pelo uso do ambiente de simulação, que se mostra altamente flexível ao permitir alterações rápidas no modelo, sem exigir grande 
esforço de compilação ou implementação em hardware. Outro benefício é a possibilidade de acompanhar a execução de forma visual, permitindo que os diagramas de 
estados sejam observados em tempo real, além de possibilitar a adição de um \textit{display} - bloco que exibe o valor contido em uma interface - em qualquer 
ponto do sistema.
